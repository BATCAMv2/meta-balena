#!/bin/sh
#
# Copyright 2018 Resinio Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -e

custom_ssh_public_keys=".os.sshKeys"
authorized_keys_path=/home/root/.ssh/authorized_keys_local
authorized_keys_perm="600"
curl_with_opts() { curl --fail --silent --connect-timeout 3 "$@"; }

# cloud_metadata:
# 1. AWS/EC2
# 2. Digital Ocean
# 3. https://www.packet.com/

#shellcheck disable=SC2034,SC2039 # /bin/sh is a symbolic link to bash on balenaOS
cloud_metadata=( \
  'http://169.254.169.254/2009-04-04/meta-data/public-keys/0/openssh-key' \
  'http://169.254.169.254/metadata/v1.json | jq .public_keys' \
  'https://metadata.packet.net/metadata | jq .ssh_keys' \
)

#shellcheck disable=SC1091 # intentional: resolved at runtime
. /usr/libexec/os-helpers-logging

# check AWS/EC2, Digital Ocean and Packet
keys_from_metadata() {
    #shellcheck disable=SC2034,SC2039 # /bin/sh is a symbolic link to bash on balenaOS
    IFS=$'\n'
    #shellcheck disable=SC2034,SC2039 # /bin/sh is a symbolic link to bash on balenaOS
    for eval_expr in "${cloud_metadata[@]}"; do
        debug "eval_expr: ${eval_expr}"
        info "Looking for SSH public keys in cloud metadata."
        keys="$(eval curl_with_opts "${eval_expr}")"
        debug "keys: ${keys}"
        [ -n "${keys}" ] && echo "${keys}" && break
    done
    unset IFS
}

is_multi_key() {
    [ -z "${1}" ] && return 1
    echo "${1}" | jq . || return 1
    return "$(echo "${1}" | jq 'if type=="array" then 0 else 1 end')"
}

add_keys_to_config() {
    [ -z "${1}" ] && return 1
    [ -f "${CONFIG_PATH}" ] || return 1

    tmpconfig="$(mktemp)"

    if is_multi_key "${1}"; then
        cat < "${CONFIG_PATH}" | jq --argjson keys "${1}" '. + {os: {sshKeys: $keys}}' > "${tmpconfig}"
    else
        cat < "${CONFIG_PATH}" | jq --arg keys "${1}" '. + {os: {sshKeys: [$keys]}}' > "${tmpconfig}"
    fi

    debug "$(cat < "${tmpconfig}")"
    info "Adding SSH public keys to config."
    if [ -s "${tmpconfig}" ] && cat < "${tmpconfig}" | jq .; then
        cat < "${tmpconfig}" > "${CONFIG_PATH}" && rm "${tmpconfig}"
    fi
}

# shellcheck disable=SC2153
if [ -n "$AUTHORIZED_KEYS_PATH" ]; then
    authorized_keys_path="$AUTHORIZED_KEYS_PATH"
fi

if [ -z "$CONFIG_PATH" ]; then
    #shellcheck disable=SC1091 # intentional: resolved at runtime
    . /usr/sbin/resin-vars
    [ -z "$CONFIG_PATH" ] && error "No config.json found."
fi

# check cloud metadata service(s) for public keys and add to config
add_keys_to_config "$(keys_from_metadata)"

ssh_keys=$(jq -r "select(${custom_ssh_public_keys} != null) | \
    ${custom_ssh_public_keys}[] //empty" "$CONFIG_PATH")

if [ -n "$ssh_keys" ]; then
    info "Setting up custom SSH public keys..."
    authorized_keys=""
    IFS="
"

    for key in $ssh_keys; do
        if [ -z "$authorized_keys" ]; then
            authorized_keys="$(printf '%s' "${key}")"
        else
            authorized_keys="$(printf '%s\n%s' "${authorized_keys}" \
                "${key}")"
        fi
    done
    unset IFS

    if [ ! -f "$authorized_keys_path" ] || [ "$(cat \
        "$authorized_keys_path")" != "$authorized_keys" ]; then
        echo "${authorized_keys}" > "$authorized_keys_path"
        chmod "$authorized_keys_perm" "$authorized_keys_path"
        info "Done."
    else
        warn "Custom SSH public keys already in place."
    fi
else
    info "No custom SSH public keys configured."
    [ ! -f "$authorized_keys_path" ] || rm -f "$authorized_keys_path"
fi
